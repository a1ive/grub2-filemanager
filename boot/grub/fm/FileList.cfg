#显示文件列表
#--根据变量$list_dir目录列出所有子项菜单
#--选择子项时，判断是目录/文件。
#----目录：设置$list_dir变量，显示新子项菜单。
#----文件：弹出操作菜单
#变量：
#--$list_dir_this 本层菜单地址
#--$list_dir 公用,传递参数
#--$wildcard 使用的通配符，为了避免枚举盘符避免冲突

insmod regexp;
insmod probe;
source "${prefix}/fm/Tools.cfg";
set file_list_src="${prefix}/fm/FileList.cfg";
set file_op_src="${prefix}/fm/FileOP.cfg";

#为了避免太长if结构，封装为函数
function funcListFile {
	#检测参数合法并设置通配符变量$wildcard
	if test -z "${list_dir}"; then
		#参数空则从盘符开始枚举
		set list_dir="";
		set wildcard="(*)";
	elif test -e "${list_dir}"; then
		#盘符(hd0,1)合法，(hd0)不合法
		set wildcard="/*";
	else
		echo;
		echo;
		funcErrorNoFindOrCanNotRead "${list_dir}";
		return 1;
	fi;
	#保存本层目录地址并设置list_dir可传递
	export list_dir;
	set list_dir_this="${list_dir}";
	
	if ! regexp '^$' "${list_dir_this}"; then
		#生成当前目录项,防止空目录自动跳回
		menuentry "返回上一级" --class go-previous{
			set list_dir="";
			regexp --set=list_dir '(^.*)/.*$' "${list_dir_this}";
			export list_dir;
			unset obj;
			unset wildcard;
			configfile ${prefix}/fm/FileList.cfg;
		}
	fi
	#枚举子项
	for obj in "${list_dir_this}"${wildcard}; do
		#去掉路径中的“msdos”
		funcRemoveCharMSDOS "${obj}";
		set obj="$str";
		unset str;
		#检查目录/文件
		if test -d "${obj}"; then
			#目录
			set icon="dir";
			if regexp '^\([c][d].*+\)$' "${obj}"; then
				set icon="iso";
			elif regexp '^\([h][d].*+\)$' "${obj}"; then
				set icon="hdd";
			fi
			if regexp '^\(proc\)$' "${obj}"; then
				echo "忽略/proc目录";
			elif regexp '^\(memdisk\)$' "${obj}"; then
				echo "忽略memdisk";
			elif regexp '^$' "${list_dir_this}"; then
				#根目录
				probe --set=devlbl -l $obj;
				probe --set=devfs -f $obj;
				menuentry "${obj} [$devfs] $devlbl" "${obj}" --class ${icon}{
					set list_dir="$2";
					configfile "${file_list_src}";
				}
				unset devlbl;
				unset devfs;
			else
				menuentry "${obj}" "${obj}" --class ${icon}{
					set list_dir="$2";
					configfile "${file_list_src}";
				}
			fi
		elif test -f "${obj}"; then
			#文件
			set icon="txt"
			funcGetFileExtName "${obj}";
			if regexp '^[iI][sS][oO]$' "${str}"; then
				set icon="iso";
			elif regexp '^[zZ][iI][pP]$' "${str}"; then
				set icon="7z";
			elif regexp '^[xXgGlL7][zZ]$' "${str}"; then
				set icon="7z";
			elif regexp '^[wW][iI][mM]$' "${str}"; then
				set icon="wim";
			elif regexp '^[pP][nN][gG]$' "${str}"; then
				set icon="png";
			elif regexp '^[jJ][pP][gG]$' "${str}"; then
				set icon="png";
			elif regexp '^[bB][mM][pP]$' "${str}"; then
				set icon="png";
			elif regexp '^[eE][fF][iI]$' "${str}"; then
				set icon="uefi";
			elif regexp '^[eE][xX][eE]$' "${str}"; then
				set icon="exe"
			fi
			unset str;
			menuentry "${obj}" "${obj}" --class ${icon} --class os{
				set list_dir="$2";
				configfile "${file_op_src}";
			}
		else
			continue;
		fi;
	done;
	if regexp '^$' "${list_dir_this}"; then
		#根目录
		funcBootDisk;
		menuentry "重启计算机" --class reboot{
			reboot;
		}
		menuentry "关闭计算机" --class halt{
			halt;
		}
	fi
	#清理环境
	unset obj;
	unset wildcard;
	echo "done!";
}

function funcBootDisk{
	for dev in (*); do
		#是否可读
		test -e ${dev};
		if test "$?" = "1"; then
			continue;
		fi;
		#去除括号
		regexp --set=device '\((.*)\)' $dev;
		#枚举
		if test -f ($device)/efi/microsoft/boot/bootmgfw.efi -a -f ($device)/efi/microsoft/boot/bcd; then
			menuentry "启动 Windows 操作系统 位于 $device" $device --class wim{
				set root=$2
				chainloader ($root)/efi/microsoft/boot/bootmgfw.efi;
				boot;
			}
		fi;
		unset devlbl;
	done;
}

#调用主体函数
funcListFile;
